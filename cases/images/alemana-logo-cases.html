<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alemana | Synced Stabilization Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">

    <style>
        :root {
            --ale-blue: #004B87;
            --ale-green: #009A44;
            --ale-light: #4FC3F7;
            --bg-dark: #020b14;
            --legacy-red: #ef4444;
        }

        body {
            background-color: var(--bg-dark);
            height: 100vh;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container-full {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* Grid de fondo sutil */
        .grid-bg {
            position: absolute; inset: 0;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: 0;
        }

        /* SVG ocupa todo el espacio y ignora el aspect ratio para llenar la tarjeta */
        svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Textos superpuestos (HTML es mejor para fuentes nítidas) */
        .labels-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        .label {
            position: absolute; top: 15%; /* Porcentaje para mantener posición relativa */
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem; /* Pequeño para que no rompa en móviles */
            letter-spacing: 2px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .label-legacy { left: 5%; color: var(--legacy-red); text-shadow: 0 0 10px rgba(239, 68, 68, 0.4); }
        .label-cloud { right: 5%; color: var(--ale-green); text-shadow: 0 0 10px rgba(0, 154, 68, 0.4); text-align: right; }

        /* Línea divisoria central */
        .divider {
            position: absolute; left: 50%; top: 10%; bottom: 10%;
            width: 1px; border-left: 1px dashed rgba(255,255,255,0.1);
            z-index: 1;
        }

        /* Estilos internos del SVG */
        .scan-line {
            stroke: white;
            stroke-width: 2;
            opacity: 0.8;
            filter: drop-shadow(0 0 5px white);
        }
        
        .guide-dot {
            fill: white;
            filter: drop-shadow(0 0 8px white);
        }

    </style>
</head>
<body>

    <div class="container-full">
        <div class="grid-bg"></div>
        <div class="divider"></div>

        <div class="labels-layer">
            <div class="label label-legacy">Legacy SAS <br><span style="font-size:0.6em; opacity:0.7">(Arritmia)</span></div>
            <div class="label label-cloud">BigQuery <br><span style="font-size:0.6em; opacity:0.7">(Sinusal)</span></div>
        </div>

        <svg viewBox="0 0 800 300" preserveAspectRatio="none">
            <defs>
                <linearGradient id="pulseGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color: var(--legacy-red)" />
                    <stop offset="45%" style="stop-color: var(--legacy-red)" />
                    <stop offset="50%" style="stop-color: #fbbf24" />
                    <stop offset="55%" style="stop-color: var(--ale-green)" />
                    <stop offset="100%" style="stop-color: var(--ale-light)" />
                </linearGradient>
                
                <filter id="glow">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                    <feMerge>
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>

            <path id="mainPath" 
                  stroke="url(#pulseGradient)" 
                  fill="none"
                  stroke-width="4"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  filter="url(#glow)"
                  d="M0,150 
                     L30,140 L40,180 L50,120 L65,160 L80,100 L95,190 L110,150
                     L140,150 L150,145 L160,155 L180,150
                     L210,150 L220,100 L230,200 L240,150
                     L300,150 L320,150 L330,120 L340,180 L350,150
                     L400,150
                     C450,150 460,80 480,80 S510,150 540,150
                     S570,220 600,220 S630,150 660,150
                     S690,80 720,80 S750,150 780,150 L800,150" />

            <line id="scanLine" x1="0" y1="0" x2="0" y2="300" class="scan-line" />
            
            <circle id="guideDot" cx="0" cy="150" r="5" class="guide-dot" />
            
        </svg>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const path = document.getElementById('mainPath');
            
            // Obtenemos referencias a los elementos SVG
            const scanLine = document.getElementById('scanLine');
            const guideDot = document.getElementById('guideDot');
            
            const length = path.getTotalLength();

            // Configuración inicial del trazo
            path.style.strokeDasharray = length;
            path.style.strokeDashoffset = length;

            let start = null;
            const duration = 5000; // Duración del loop

            function animate(timestamp) {
                if (!start) start = timestamp;
                let progress = (timestamp - start) / duration;

                if (progress > 1) {
                    start = timestamp;
                    progress = 0;
                }

                // 1. Dibujamos la línea
                const drawLength = length * progress;
                path.style.strokeDashoffset = length - drawLength;

                // 2. Obtenemos la coordenada EXACTA dentro del sistema de coordenadas del SVG (0-800)
                // No importa si el iframe mide 300px o 1000px, getPointAtLength devuelve valores relativos al viewBox
                const point = path.getPointAtLength(drawLength);

                // 3. Movemos la barra vertical (SVG Line)
                // Modificamos sus atributos x1 y x2. Y1 e Y2 se mantienen fijos (0 a 300)
                scanLine.setAttribute("x1", point.x);
                scanLine.setAttribute("x2", point.x);

                // 4. Movemos el punto (SVG Circle)
                guideDot.setAttribute("cx", point.x);
                guideDot.setAttribute("cy", point.y);

                requestAnimationFrame(animate);
            }

            requestAnimationFrame(animate);
        });
    </script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        // 1. Capturar los parámetros con los que llegamos a esta página
        const params = new URLSearchParams(window.location.search);
        
        const mode = params.get('v');       // ej: global
        const country = params.get('pais'); // ej: cl
        const lang = params.get('lang');    // ej: es, en

        // 2. Referencia al botón de volver (asegúrate que tu <a> tenga id="btn-back")
        const backBtn = document.getElementById('btn-back');
        
        // Si no usaste ID, intentamos buscar cualquier link que vaya al index
        const fallbackBtn = document.querySelector('a[href*="index.html"]');
        const targetBtn = backBtn || fallbackBtn;

        if (targetBtn) {
            // 3. Construir la URL de regreso preservando el estado
            let returnUrl = "../index.html?";
            
            // Solo agregamos los parámetros si existen
            if (mode) returnUrl += `v=${mode}&`;
            if (country) returnUrl += `pais=${country}&`;
            
            // Para el idioma, usamos 'initialLang' para que el index lo fuerce al cargar
            if (lang) returnUrl += `initialLang=${lang}`;

            // 4. Asignar la nueva URL al botón
            targetBtn.href = returnUrl;
            
            console.log("Link de retorno configurado a:", returnUrl);
        }

        // OPCIONAL: Si quieres ocultar contenido en inglés/español dentro del caso
        // Puedes usar clases CSS como .lang-es o .lang-en
        if (lang === 'es') {
            document.body.classList.add('is-spanish');
        } else {
            document.body.classList.add('is-english');
        }
    });
</script>
</body>
</html>